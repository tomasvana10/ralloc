#!/usr/bin/env node

import { execSync } from "node:child_process";
import { existsSync, readFileSync, writeFileSync } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { confirm, input, password } from "@inquirer/prompts";
import chalk from "chalk";
import * as dotenv from "dotenv";

const DEFAULT_DEV_WEB_PORT = 3001;
const DEFAULT_PROD_WEB_PORT = 3000;
const DEFAULT_WS_PORT = 6767;
const DOCKER_REDIS_URL = "redis://redis:6379";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, "..");

function commandExists(cmd) {
  try {
    execSync(`command -v ${cmd}`, { stdio: "ignore" });
    return true;
  } catch {
    return false;
  }
}

function writeEnvFile(_filename, vars, prefix) {
  const absPath = path.join(ROOT_DIR, prefix, _filename);

  let existing = {};
  if (existsSync(absPath))
    existing = dotenv.parse(readFileSync(absPath, "utf-8"));

  const merged = { ...existing, ...vars };
  const content = Object.entries(merged)
    .map(([key, value]) => `${key}=${value}`)
    .join("\n");

  writeFileSync(absPath, `${content}\n`);
  console.log(chalk.green(`Updated ${absPath}`));
}

function writeRedisConf(filename, password) {
  const absPath = path.join(ROOT_DIR, filename);
  writeFileSync(
    absPath,
    `bind 0.0.0.0\nprotected-mode no\nrequirepass ${password}`,
  );
  console.log(chalk.green(`Updated ${absPath}`));
}

export function isHttpUrl(value) {
  try {
    const url = new URL(value);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch {
    return "Please enter a full HTTP URL (like https://ralloc.xyz)";
  }
}

export function isWSUrl(value) {
  try {
    const url = new URL(value);
    return url.protocol === "ws:" || url.protocol === "wss:";
  } catch {
    return "Please enter a full WebSocket URL (like wss://ws.ralloc.xyz)";
  }
}

async function getPassword(asConfirmation, firstPassword = null, mask = "*") {
  if (asConfirmation && !firstPassword)
    throw new Error(
      "Must provide first password entry to compare against confirmation",
    );
  return await password({
    message: asConfirmation ? "  Confirm password:" : "  Enter password:",
    mask,
    validate: (val) => {
      if (val.length < 8) return "Password must be at least 8 characters";
      if (asConfirmation && firstPassword !== val)
        return "Passwords don't match";
      return true;
    },
  });
}

async function getPort(message, default_, alertMsg = null) {
  const port = await input({
    message,
    default: default_.toString(),
    validate: (val) => {
      const num = parseInt(val, 10);
      if (Number.isNaN(num) || num < 1 || num > 65535)
        return "Please enter a valid port number (1-65535)";
      return true;
    },
  });
  const parsedPort = parseInt(port, 10);

  if (parsedPort !== default_ && alertMsg) {
    console.log(chalk.yellow(alertMsg));
  }

  return parsedPort;
}

async function setupDevEnvironment() {
  console.log(
    chalk.bold(chalk.bgGreen("\nDevelopment Environment Configuration")),
  );

  // web env config
  const devWebPort = await getPort(
    "Internal NextJS port:",
    DEFAULT_DEV_WEB_PORT,
    `Please update the port mappings in ${chalk.cyan("docker/compose.dev.yaml")}\n`,
  );

  const devWebEnv = {
    URL: `http://localhost:${devWebPort}`,
    AUTH_URL: `http://localhost:${devWebPort}`,
  };
  devWebEnv.PORT = devWebPort;
  const devWsEnv = { WS_HOST: "0.0.0.0" };
  const devAppsEnv = {};

  // ws env config
  const devWsPort = await getPort(
    "Internal WebSocket Server port:",
    DEFAULT_WS_PORT,
    `Please update the port mappings in ${chalk.cyan("docker/compose.dev.yaml")}\n`,
  );
  devWsEnv.WS_PORT = devWsPort;

  const devWsUrl = await input({
    message: "WebSocket Server URL:",
    default: `ws://localhost:${devWsPort}`,
    validate: isWSUrl,
  });
  devWsEnv.WS_URL = devWsUrl;

  // core env config
  const devUseBuiltinRedis = await confirm({
    message: "Use the built-in Redis service with Docker Compose?",
    default: true,
  });

  if (devUseBuiltinRedis) {
    devAppsEnv.REDIS_URL = DOCKER_REDIS_URL;
  } else {
    const devRedisUrl = await input({
      message: "Redis database URL:",
      default: "redis://localhost:6379",
    });
    devAppsEnv.REDIS_URL = devRedisUrl;

    console.log(
      chalk.yellow(
        `Please remove the redis service in ${chalk.cyan("docker/compose.dev.yaml")}\n`,
      ),
    );
  }

  const devOpenRedis = await confirm({
    message: "Open the Redis database to your local network?",
    default: false,
  });

  if (devOpenRedis) {
    const passwordA = await getPassword(false);
    await getPassword(true, passwordA);
    devAppsEnv.REDIS_PASSWORD = passwordA;
  }

  const devEnableRatelimiting = await confirm({
    message: "Enable NextJS API rate limiting?",
    default: false,
  });
  devAppsEnv.ENABLE_RATELIMITING = devEnableRatelimiting ? "1" : "0";

  const devEnableGuestAuth = await confirm({
    message:
      "Allow users to sign in as a guest for a one-time session? (can lead to increased API abuse)",
    default: false,
  });
  devAppsEnv.ENABLE_GUEST_AUTH = devEnableGuestAuth ? "1" : "0";

  console.log();
  writeEnvFile(".env.development", devWebEnv, "apps/web");
  writeEnvFile(".env.development", devWsEnv, "apps/ws");
  writeEnvFile(".env.development", devAppsEnv, "apps");
  console.log();
  if (devOpenRedis) writeRedisConf("redis.dev.conf", devAppsEnv.REDIS_PASSWORD);
}

async function setupProdEnvironment() {
  console.log(
    chalk.bold(chalk.bgMagenta("Production Environment Configuration")),
  );

  const prodUrl = await input({
    message: "App URL:",
    validate: isHttpUrl,
  });

  const prodWebEnv = {
    URL: prodUrl,
    AUTH_URL: prodUrl,
  };
  const prodWsEnv = { WS_HOST: "0.0.0.0" };
  const prodAppsEnv = {};

  // web env config
  const prodWebPort = await getPort(
    "Internal NextJS port:",
    DEFAULT_PROD_WEB_PORT,
    `Please update the port mappings in ${chalk.cyan("docker/compose.prod-*.yaml")}\n`,
  );
  prodWebEnv.PORT = prodWebPort;

  const prodAuthDomain = await input({
    message:
      "Authentication domain (only enter a value if your websocket server is on its own subdomain - " +
      "for example, enter .ralloc.xyz if you are hosting the app on ralloc.xyz and the websocket server is " +
      "located at ws.ralloc.xyz):",
    required: false,
  });
  if (prodAuthDomain) prodWebEnv.AUTH_DOMAIN = prodAuthDomain;

  // ws env config
  const prodWsPort = await getPort(
    "Internal WebSocket Server port:",
    DEFAULT_WS_PORT,
    `Please update the port mappings in ${chalk.cyan("docker/compose.prod-*.yaml")}\n`,
  );
  prodWsEnv.WS_PORT = prodWsPort;

  const prodWsUrl = await input({
    message: "WebSocket Server URL:",
    required: true,
    validate: isWSUrl,
  });
  prodWsEnv.WS_URL = prodWsUrl;

  // core env config
  const prodUseBuiltinRedis = await confirm({
    message: "Use the built-in Redis service with Docker Compose?",
    default: true,
  });

  if (prodUseBuiltinRedis) {
    prodAppsEnv.REDIS_URL = DOCKER_REDIS_URL;
  } else {
    const prodRedisUrl = await input({
      message: "Enter your Redis database URL:",
      default: "redis://localhost:6379",
    });
    prodAppsEnv.REDIS_URL = prodRedisUrl;

    console.log(
      chalk.yellow(
        `Please remove the redis service in ${chalk.cyan("docker/compose.prod-*.yaml")}\n`,
      ),
    );
  }

  const prodOpenRedis = await confirm({
    message: "Open the Redis database to your local network?",
    default: false,
  });

  if (prodOpenRedis) {
    const passwordA = await getPassword(false);
    await getPassword(true, passwordA);
    prodAppsEnv.REDIS_PASSWORD = passwordA;
  }

  const prodEnableRatelimiting = await confirm({
    message: "Enable NextJS API rate limiting?",
    default: true,
  });
  prodAppsEnv.ENABLE_RATELIMITING = prodEnableRatelimiting ? "1" : "0";

  const prodEnableGuestAuth = await confirm({
    message:
      "Allow users to sign in as a guest for a one-time session? (can lead to increased API abuse)",
    default: false,
  });
  prodAppsEnv.ENABLE_GUEST_AUTH = prodEnableGuestAuth ? "1" : "0";

  console.log();
  writeEnvFile(".env.production", prodWebEnv, "apps/web");
  writeEnvFile(".env.production", prodWsEnv, "apps/ws");
  writeEnvFile(".env.production", prodAppsEnv, "apps");
  console.log();
  if (prodOpenRedis)
    writeRedisConf("redis.prod.conf", prodAppsEnv.REDIS_PASSWORD);
}

async function setupDocker() {
  const createNetwork = await confirm({
    message: "Create Docker network `ralloc_net`?",
    default: true,
  });

  if (createNetwork) {
    try {
      execSync("docker network create ralloc_net", { stdio: "pipe" });
      console.log(chalk.green("Created Docker network `ralloc_net`."));
    } catch (e) {
      if (e.stderr?.toString().includes("already exists")) {
        console.log(
          chalk.yellow("Docker network `ralloc_net` already exists."),
        );
      } else {
        console.log(chalk.red("Failed to create Docker network."));
        console.log(e.message);
      }
    }
  }
}

function displayNextSteps() {
  console.log(chalk.bold(chalk.bgCyan("\nNext Steps")));

  console.log(`1. Generate an auth secret:\n`);
  console.log(`   ${chalk.green("cd apps/web")}`);
  console.log(`   ${chalk.green("pnpm dlx auth secret")}\n`);

  console.log(
    `2. Add OAuth providers to your environment using the add-auth-providers script:\n`,
  );
  console.log(`   ${chalk.green("./scripts/add-auth-providers")}\n`);

  console.log(`3. Run the app:\n`);
  console.log(
    `   - Run in dev:          ${chalk.green("pnpm run dev")}`,
  );
  console.log(
    `   - Run in prod (local): ${chalk.green("pnpm run prod-local")}`,
  );
  console.log(
    `   - Run in prod (CI/CD): ${chalk.green("pnpm run prod-ci")}\n`,
  );

  console.log(chalk.green(chalk.bold("Environment setup complete!\n")));
}

async function main() {
  if (!commandExists("pnpm")) {
    console.log(chalk.red("pnpm is not installed."));
    console.log(`Install it: ${chalk.cyan("https://pnpm.io/installation")}`);
    process.exit(1);
  }
  console.log(chalk.bold("\nSetup Ralloc for Self-Hosting"));
  console.log("This script sets up the Ralloc environment.");
  console.log(chalk.italic("Press Ctrl+C at any time to exit."));

  if (!commandExists("docker")) {
    console.log(chalk.red("Docker is not installed."));
    console.log(
      `Install it: ${chalk.cyan("https://docs.docker.com/get-docker/")}`,
    );
    process.exit(1);
  }

  console.log();
  const setupDev = await confirm({
    message: "Would you like to set up the development environment?",
    default: true,
  });
  if (setupDev) {
    await setupDevEnvironment();
  } else {
    console.log();
  }

  let setupProd = true;
  if (setupDev) {
    setupProd = await confirm({
      message: "Would you like to set up the production environment?",
      default: true,
    });
  }
  if (setupProd) {
    await setupProdEnvironment();
  }

  await setupDocker();
  displayNextSteps();
}

main().catch((err) => {
  if (err.name === "ExitPromptError") {
    console.log(chalk.yellow("\nEnvironment setup cancelled.\n"));
    process.exit(0);
  }
  console.error(chalk.red("\nAn error occurred:"), err);
  process.exit(1);
});
